package main

import (
	"fmt"
	"time"
)





// // функция, которая принимает время и блокирует текущую горутину до окончания этого времени
// func sleep(duration time.Duration) {
// 	// определяем текущее время
// 	startTime := time.Now()
// 	// ждем, пока не пройдет нужное время, тем самым блокируя выполнение горутины, в которой запущена эта функция
// 	// это плохой спосооб, потому что каждое мгновение мы делаем бесполезные сравнения,
// 	// вызов функции time.Since и итерации
// 	for time.Since(startTime) < duration {
// 	}
// }

// функция, которая принимает время и блокирует текущую горутину до окончания этого времени
func sleep(duration time.Duration) {
	// создаем канал типа структуры без полей, потому что она почти не занимает памяти
	ch := make(chan struct{})
	// запускаем горутину
	go func() {
		// по истечении времени вызываем функцию, которая отправляет в канал пустую структуру
		time.AfterFunc(duration, func() { ch <- struct{}{} })
	}()
	// ожидаем чтение из канала, тем самым блокируя горутину, в которой вызвана эта функция
	<-ch
}

func main() {
	fmt.Println("Начало")
	sleep(time.Second * 3)
	fmt.Println("Конец")
}
