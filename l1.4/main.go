package main

import (
	// пакет для управления информацией о времени жизни и отмене
	"context"
	"fmt"
	// пакет для работы с ос
	"os"
	// пакет для работы с системными сигналами
	"os/signal"
	"sync"
	// пакет для работы со временем
	"time"
)

// воркер, который принимает на вход контекст, канал и указатель на waitgroup
func worker(ctx context.Context, jobs chan int, wg *sync.WaitGroup) {
	// отложенное уменьшение счетчика на 1
	defer wg.Done()
	// бесконечный цикл для работы горутины
	for {
		// оператор select case для работы с несколькими каналами
		select {
		// чтение из канала jobs
		case job := <-jobs:
			// вывод в stdout
			fmt.Println(job)
			// ждем секунду для имитации долгой задачи
			time.Sleep(time.Second * 1)
		// чтение из канала об отмене контекста
		case <-ctx.Done():
			// печать сообщения о ctrl + c
			fmt.Println("Нажали ctrl + c, изящное завершение горутины")
			// выход из цикла(прекращение работы горутины)
			return
		}
	}
}

func main() {
	// инициализация канала jobs
	jobs := make(chan int, 5)
	// инициализация waitgroup
	var wg sync.WaitGroup
	// инициализация переменной для количества запускаемых воркеров
	numWorkers := 3

	// инициализация контекста отмены и функции отмены контекста
	ctx, cancel := context.WithCancel(context.Background())

	// запуск анонимной горутины для отслеживания нажатия ctrl+c
	go func() {
		// инициализация буферизованного канала для получения сигналов
		sigchan := make(chan os.Signal, 1)
		// регистрация канала sigchan, чтобы он получал сигналы отмены
		signal.Notify(sigchan, os.Interrupt)
		// блокировка горутины, пока не будет получен сигнал отмены(ctrl + c)
		<-sigchan
		// печать текста о нажатии ctrl + c
		fmt.Println("Нажали ctrl + c, передаю контекст горутинам")
		// функция отмены контекста
		cancel()
	}()

	// цикл для запуска воркеров
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go worker(ctx, jobs, &wg)
	}

	// анонимная горутина для постоянной записи в канал jobs с переодичностью полсекунды
	go func() {
		for {
			jobs <- 1
			time.Sleep(time.Millisecond * 500)
		}
	}()

	// ожидание завершения всех горутин и закрытие канала
	wg.Wait()
	close(jobs)
}





// package main

// import (
// 	"fmt"
// 	// пакет для работы с ос
// 	"os"
// 	// пакет для работы с системными сигналами
// 	"os/signal"
// 	"sync"
// 	// пакет для работы со временем
// 	"time"
// )

// // воркер, который принимает на вход канал quit, канал jobs и указатель на waitgroup
// func worker(quit chan bool, jobs chan int, wg *sync.WaitGroup) {
// 	// отложенное уменьшение счетчика на 1
// 	defer wg.Done()
// 	// бесконечный цикл для работы горутины
// 	for {
// 		// оператор select case для работы с несколькими каналами
// 		select {
// 		// чтение из канала jobs
// 		case job := <-jobs:
// 			// вывод в stdout
// 			fmt.Println(job)
// 			// ждем секунду для имитации долгой задачи
// 			time.Sleep(time.Second * 1)
// 		// чтение из канала для выхода из горутины
// 		case <-quit:
// 			// печать сообщения о ctrl + c
// 			fmt.Println("Нажали ctrl + c, изящное завершение горутины")
// 			// выход из цикла(прекращение работы горутины)
// 			return
// 		}
// 	}
// }

// func main() {
// 	// инициализация канала jobs
// 	jobs := make(chan int, 5)
// 	// инициализация waitgroup
// 	var wg sync.WaitGroup
// 	// инициализация переменной для количества запускаемых воркеров
// 	numWorkers := 3
// 	// инициализация канала quit для изящного завершения работы горутин
// 	quit := make(chan bool)

// 	// запуск анонимной горутины для отслеживания нажатия ctrl+c
// 	go func() {
// 		// инициализация буферизованного канала для получения сигналов
// 		sigchan := make(chan os.Signal, 1)
// 		// регистрация канала sigchan, чтобы он получал сигналы отмены
// 		signal.Notify(sigchan, os.Interrupt)
// 		// блокировка горутины, пока не будет получен сигнал отмены(ctrl + c)
// 		<-sigchan
// 		// печать текста о нажатии ctrl + c
// 		fmt.Println("Нажали ctrl + c, передаю контекст горутинам")
// 		// закрываем канал, чтобы горутины прекратили свою работу
// 		close(quit)
// 	}()

// 	// цикл для запуска воркеров
// 	for i := 0; i < numWorkers; i++ {
// 		wg.Add(1)
// 		go worker(quit, jobs, &wg)
// 	}

// 	// анонимная горутина для постоянной записи в канал jobs с переодичностью полсекунды
// 	go func() {
// 		for {
// 			jobs <- 1
// 			time.Sleep(time.Millisecond * 500)
// 		}
// 	}()

// 	// ожидание завершения всех горутин и закрытие канала
// 	wg.Wait()
// 	close(jobs)
// }





// Мне более удобным кажется контекст, потому что в реальных проектах мы во все функции передаем контекст,
// даже если он там не используется, поэтому легче будет работать с ним, нежели создавать дополнительный канал
// и передавать его в каждую функцию. Также у контекста есть удобство найстроки таймаута и возможность передавать
// дополнительную информацию