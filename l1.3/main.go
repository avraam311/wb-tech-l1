package main

import (
	"fmt"
	"log"
	"sync"
)

// воркер для чтения из канала jobs, который также принимает waitgroup в качестве второго аргумента для ожидания завершения всех горутин
func worker(jobs chan int, wg *sync.WaitGroup) {
	// отложенное уменьшение счетчика wg на 1, чтобы wg мог запустить работу основной горутины, когда все горутины завершат свою работу
	defer wg.Done()
	// чтение всех сообщений из канала jobs
	for job := range jobs {
		// печать сообщения из канала в stdout
		fmt.Println(job)
	}
}

func main() {
	jobs := make(chan int)
	// инициализация waitgroup
	var wg sync.WaitGroup
	// объявление 2 переменных типа int для хранения количества воркеров и количества данных для записи в канала jobs
	var N, n int
	n = 10
	// чтение из stdin
	_, err := fmt.Scan(&N)
	if err != nil {
		log.Fatal("failed to scan stdin")
	}

	// запуск необходимого количества воркеров в горутинах
	for i := 1; i <= N; i++ {
		// увеличение счетчкика wg на 1, чтобы основная горутина ждала завершения этой
		wg.Add(1)
		go worker(jobs, &wg)
	}

	// изначально код был такой, потому что в условии сказано "постоянная запись в канал", однако такой процесс не прерывается,
	// поэтому ограничил количество поступаемых данных переменной n
	// также запускаю цикл в анонимной горутине, чтобы компилятор мог доходить до кода с закрытием канала,
	// вот только тогда надо ставить close ниже wg.Wait(), потому что канал сразу закрывается до завершения
	// всех горутин и мы получаем панику
	// go func() {
	//     for {
	//         jobs <- 1
	//     }
	// }

	for i := 1; i <= n; i++ {
		jobs <- 1
	}

	// закрытие канала jobs, чтобы горутины не ждали чтение из него и не было блокировок
	close(jobs)

	// ждем завершения всех горутин
	wg.Wait()
}
