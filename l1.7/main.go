// package main

// import (
// 	"fmt"
// 	"sync"
// )

// func main() {
// 	// инициализация мютекса, можно также использовать sync.RWMutex, однако тут смысла нет, потому что
//  // мы только делаем запись в мапу, а он предзназначен для случаев, когда нескольким горутинам
//  // надо читать одновременно из мапы по одному ключу
// 	var mux sync.Mutex
// 	// объявление мапы с ключами и значениями типа int
// 	m := make(map[int]int)
// 	var wg sync.WaitGroup
//
// 	// запускаем 1000 горутин
// 	for i := 0; i < 1000; i++ {
// 		wg.Add(1)
// 		go func(i int) {
// 			defer wg.Done()
// 			// блокируем горутины в момент записи в мапу, чтобы избежать панику(гонка горутин)
// 			// несмотря на то, что мы записываем данные в мапу по разным ключам в разных горутинах,
// 			// использование мютексов является обязательным, так как мапа является потоконебезопасной
// 			mux.Lock()
// 			// запись в мапу
// 			m[i] = i
// 			// разблокировка горутины после добавления данных в мапу
// 			mux.Unlock()
// 			fmt.Printf("значение %v с ключом %v добавлено в мапу\n", i, i)
// 		}(i)
// 	}

// 	wg.Wait()
// }





// package main

// import (
// 	"fmt"
// 	"sync"
// )

// func main() {
// 	// объявление потокобезопасной мапы
// 	var syncM sync.Map
// 	var wg sync.WaitGroup
// 	// запускаем 1000 горутин
// 	for i := 0; i < 1000; i++ {
// 		wg.Add(1)
// 		go func(i int) {
// 			defer wg.Done()
// 			// добавление данных
// 			// потокобезопасная мапа предназначена для определенных случаев: много чтений,
// 			// ключи редко перезаписываются, разные горутины используют разные ключи, однако есть минусы:
// 			// менее предсказуемая производительность, не типобезопасный интерфейс
// 			syncM.Store(i, i)
// 			fmt.Printf("значение %v с ключом %v добавлено в мапу\n", i, i)
// 		}(i)
// 	}

// 	wg.Wait()
// }





package main

import (
	"fmt"
	"sync"
)

// инициализация константы, хранящей количество шард(для разделения словаря на 32 куска)
// 32 выбрано случайно, обычно количество шардов основывается на количестве ядер и уровне конкурентности
const shards = 32

// объявляем слайс указатель на структуру, чтобы хранить словарь по частям
type ConcurrentMap []*MapShard

// один отдельный шард состоит из двух вещей: внутренняя карта для хранения пар ключ-значение,
// RWMutex - блокировка, позволяющая многим процессам читать одновременно,
// но ограничивающая запись одной горутиной
type MapShard struct {
	items map[int]int
	sync.RWMutex
}

// функция New создает новый экземпляр ConcurrentMap с заранее определённым количеством шардов,
// внутри каждого шарда создаётся пустая карта и соответствующая блокировка
func New() ConcurrentMap {
	cm := make(ConcurrentMap, shards)
	for i := range cm {
		cm[i] = &MapShard{
			items: make(map[int]int),
		}
	}
	return cm
}

// функция Set предназначена для добавления новой пары ключ-значение в словарь
// алгоритм выбирает подходящий шард путем простого целочисленного деления ключа на количество шардов
// перед изменением соответствующего шарда устанавливается блокировка, гарантирующая безопасность
func (cm ConcurrentMap) Set(key int, value int) {
	shard := key % shards
	cm[shard].Lock()
	defer cm[shard].Unlock()
	cm[shard].items[key] = value
}

func main() {
	// объявляем новую мапу
	cm := New()
	var wg sync.WaitGroup

	// добавляем в нашу конкурентну мапу 1000 значений
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			cm.Set(i, i)
		}(i)
	}

	wg.Wait()

	for i := 0; i < 1000; i++ {
		// вычисляем нужный шард
		shardIndex := i % shards
		// получаем значение и bool нахождения значения по ключу
		value, ok := cm[shardIndex].items[i]
		// выводим значение
		fmt.Println(value)
		// если значение не найдено или не соответствует искомому, вызываем панику
		if !ok || value != i {
			panic(fmt.Sprintf("Ошибка! Ключ %d не найден или неверное значение (%v)", i, value))
		}
	}

	// опять читаем все значения из мапы, но только конкурентно для большей наглядности
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			shardIndex := i % shards
			cm[shardIndex].RLock()
			value, ok := cm[shardIndex].items[i]
			cm[shardIndex].RUnlock()
			fmt.Println(value)

			if !ok || value != i {
				panic(fmt.Sprintf("Ошибка! Ключ %d не найден или неверное значение (%v)", i, value))
			}
		}(i)
	}

	wg.Wait()
	// шардинг нужен для очень высоких нагрузок
}
