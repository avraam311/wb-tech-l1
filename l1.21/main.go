package main

import (
	"fmt"
)

// интерфейс, который нам нужен
type writerI interface {
	write(data string)
}

// старый интерфейс
type loggerI interface {
	log(message string)
}

// реализация интерфейса logger
type logger struct{}

// реализация интерфейса logger
func (l *logger) log(message string) {
	fmt.Println("Logging:", message)
}

// объявление адаптера с полем loggerInterface для доступа к функциям старого интерфейса логгера
type loggerAdapter struct {
	logger loggerI
}

// реализация интерфейса writerI
func (a *loggerAdapter) write(data string) {
	a.logger.log(data)
}

// клиентская функция, которая запрашивает интерфейс writerI
func ClientCode(writer writerI) {
	writer.write("Hello, adapter pattern!")
}

func main() {
	// инициализация старого логгера
	logger := &logger{}
	// инициализация адаптера
	adapter := &loggerAdapter{logger}
	// используем адаптер для работы клиентской функции
	ClientCode(adapter)
}

// применимость: паттерн Adapter полезен тогда, когда мы хотим повторно использовать существующую реализацию
// (пакет, класс), однако её интерфейс отличается от нужного нам интерфейса.
// Вместо переписывания исходного компонента создаётся новый класс(адаптер),
// который конвертирует один интерфейс в другой, делая компоненты совместимыми друг с другом.

// плюсы: нет надобности переписывать старые классы, особенно, если их реализация большая и сложная,
// легкость добавления нового функционала

// минусы: чем больше адаптеров, тем сложнее проект, нужно постоянно следить за соответствием интерфейсов

// примеры реального использования:
// 1. Использование сторонних библиотек: допустим, библиотека для обработки изображений имеет свой
// собственный интерфейс для открытия файлов, а ваш фреймворк требует иной интерфейс загрузки изображений.
// Вы можете создать адаптер, который переконвертирует методы библиотеки в нужные вашему приложению.
// 2. Конверсия типов данных между протоколами передачи: например, ваша программа общается
// с микросервисами через gRPC, но иногда возникает необходимость отправлять запросы через HTTP API.
// Чтобы избежать дублирования кода, можно создать адаптер, преобразовывая типы данных из одного формата в другой.
